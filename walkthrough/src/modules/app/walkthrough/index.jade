section
  :markdown

    # FSG Walkthrough

    Welcome! Throughout this walkthrough the [futuristic-sass-guide](https://github.com/gilbox/futuristic-sass-guide)
    is referred to as the **FSG**.
    The purpose of this walkthrough is to present the FSG in a more natural way. If the FSG is
    the technical manual, then this is the study guide.

section
  :markdown

    # Subclassing

    The term **subclassing** is used several times throughout the FSG. This is a very
    important concept because subclassing is often better than using `@extend` or `@mixin`.
    When `.A` and `.B` are applied to the same element `<div class="A B">`,
    we say that `.B` **subclasses** `.A` **if `.B` appears after `.A` in the stylesheet**
    (and thus will override or augment rules in `.A`)

questions.Questions--3
  question
    :markdown
      ``` css
        .A {
         color: red;
         border: 1px solid green;
        }

        .B {
         color: blue;
        }
      ```

      ``` html
        <h2 class="A B">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="true") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") Both <code>A</code> subclasses <code>B</code>, and <code>B</code> subclasses <code>A</code>

  question
    :markdown
      ``` css
        .B {
         font-size: 20px;
        }
        .A {
         color: orange;
        }
      ```
      ``` html
        <h2 class="A B">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="true") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="false") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") Both <code>A</code> subclasses <code>B</code>, and <code>B</code> subclasses <code>A</code>

  question
    :markdown
      ``` css
        .A { ... }
        .B { ... }
        .C { ... }
      ```
      ``` html
        <h2 class="C B A">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="true") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") <code>B</code> subclasses <code>C</code>
      answer-toggle(correct="true") <code>C</code> subclasses <code>A</code>
      answer-toggle(correct="true") <code>C</code> subclasses both <code>B</code> <strong>and</strong> <code>A</code>

section
  :markdown

    # Creating a new Module

    Whenever we need to add new styles to a page, our first instinct should be to
    create a new **Module** or to augment an existing Module.

    Module class names are **.TitleCase** and should reside inside of a SASS partial
    named after the Module. Module files (partials) live inside the `modules/` folder.
    For example, a `.DialogBox` Module should be defined inside of `modules/_DialogBox.scss`.

    All classes names inside of a Module file must be namespaced by
    the Module name. A class is namespaced with the module name followed by dash (ie `.DialogBox-`).
    The only exception to this are state classes, which are classes which are never
    namespaced and begin with `.is`

questions.Questions--3
  question
    :markdown
      ``` css
        .FunBox {
          width:100%;
        }

        .FunBox-btn {
          border: 5px solid green;
          white-space: nowrap;
        }

        .isActive.FunBox-btn {
          color: red;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="true") Is this a valid Module File?

  question
    :markdown
      ``` css
        .SearchBox {
          border: 1px solid black;
        }

        .SearchBox-closeBtn {
          background: black;
          color:white;
        }

        .SearchButton {
          text-decoration: none;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") Is this a valid Module File?

  question
    h5 Which of the following are valid Module Names?
    answer-toggle-group
      answer-toggle(correct="true") <code>Btn</code>
      answer-toggle(correct="false") <code>SearchBox-closeBtn</code>
      answer-toggle(correct="false") <code>jokeBox</code>
      answer-toggle(correct="true") <code>DialogBoxBtn</code>
      answer-toggle(correct="false") <code>HeaderWidget-Lower</code>
      answer-toggle(correct="false") <code>Promo_Banner</code>

section
  :markdown

    # Adding Rules to Modules

    Any time we need to add a style rule to a Module, our first instinct
    should be to add a **Module Element** class to the module. For example,
    if we have a Module `.Btn` and need to style an image icon within the button
    then we create the class `.Btn-imageIcon`. Note how `imageIcon` is camelCase and is namespaced by
    the Module, `.Btn-`.

    Here's what our button looks like in code:

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }
    ```

    ``` html
    <button class="Btn">
      Click Me <span class="Btn-imageIcon"></span>
    </button>
    ```

questions.Questions--2
  question
    h5 Which are valid Module Element classes?
    answer-toggle-group
      answer-toggle(correct="false") <code>.Btn-vector-icon</code>
      answer-toggle(correct="false") <code>.Btn-Middle</code>
      answer-toggle(correct="true") <code>.Btn-iconTopLeft</code>
      answer-toggle(correct="false") <code>.Btn-icon--small</code>
      answer-toggle(correct="false") <code>.btnIcon</code>
      answer-toggle(correct="true") <code>.Btn-littleLebowskiUrbanAchievers</code>

  question
    :markdown
      ``` css
        .SearchBox {
          border: 1px solid black;
        }
        .SearchBox-closeBtn {
          background: black;
          color:white;
        }
        .SearchBox-expandBtn {
          background: blue;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>.SearchBox</code> is a Module Element
      answer-toggle(correct="true") <code>.SearchBox-closeBtn</code> is a Module Element
      answer-toggle(correct="true") <code>.SearchBox-expandBtn</code> is a Module Element

section
  :markdown
    # Modifying Module Elements

    Now, consider that our designer comes along and hands us a new requirement
    for a new button. This new button is very similar to our existing button
    with it's icon, except that this new button has a *bigger* icon. One way to
    create this new style is with a **Module Element Modifier**.

    ``` html
    <button class="Btn">
      Click Me <span class="Btn-imageIcon Btn-imageIcon--bigger"></span>
    </button>
    ```

    In the markup above, `.Btn-imageIcon--bigger` is our new **Module Element Modifier**.
    Note that this new Modifier **subclasses** our original **Module Element**
    `Btn-imageIcon`. Here's what the updated stylesheet looks like:

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }

    .Btn-imageIcon--bigger {
      height: 30px;
    }
    ```

    Modifiers **always** follow these two rules:

    1. Modifiers always subclass another class
    2. Modifiers are always named after the class which they subclass with the addition
       of 2 dashes, followed by a camelCased name

    Modifiers are also unique because **we may apply multiple Modifiers to one DOM element**.
    In contrast, we are **not** allowed to apply multiple Module or Module Element classes
    to the same DOM element.

    # Modifying Modules

    As an alternative to using **Element Modifiers**, we can create variations of existing styles
    using **Module Modifiers**. Consider again the same scenario presented above where
    a design change calls for a new button. Here's what the new markup will look like
    if we use a Module Modifier instead of an Element Modifier:

    ``` html
    <button class="Btn Btn--bigger">
      Click Me <span class="Btn-imageIcon"></span>
    </button>
    ```

    To create a syling rule for our Module Modifier, this is one of the few times when
    the FSG recommends using a
    [**descendant selector**](http://www.w3.org/TR/CSS21/selector.html#descendant-selectors):

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }

    .Btn--bigger .Btn-imageIcon { /* this is a descendant selector */
      height: 30px;
    }
    ```

questions.Questions--3
  question
    :markdown
      ``` css
        .DialogBox {
          border: 1px solid black;
        }

        .DialogBox-closeBtn--bigger {
          height: 30px;
        }

        .DialogBox-closeBtn {
          background: black;
          color:white;
          height: 30px;
        }

        .DialogBox-expandBtn {
          background: blue;
        }

        .DialogBox-expandBtn--bigger {
          background: blue;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>.DialogBox-closeBtn--bigger</code> is ordered correctly in the CSS file
      answer-toggle(correct="true") <code>.DialogBox-expandBtn--bigger</code> is ordered correctly in the CSS file

  question
    h5 Which are valid <em>Element</em> Modifier classes?
    answer-toggle-group
      answer-toggle(correct="false") <code>.Btn--smaller</code>
      answer-toggle(correct="true") <code>.Btn-iconTop--smaller</code>
      answer-toggle(correct="false") <code>.DialogBox--fun-pullRight</code>
      answer-toggle(correct="true") <code>.DialogBox-iconTopLeft--pushLeft</code>
      answer-toggle(correct="false") <code>.SmallText-mini-evenSmaller</code>
      answer-toggle(correct="true") <code>.Btn-littleLebowskiUrbanAchievers--width100pct</code>

    h5 Which are valid <em>Module</em> Modifier classes?
    answer-toggle-group
      answer-toggle(correct="true") <code>.Btn--smaller</code>
      answer-toggle(correct="false") <code>.Btn-littleLebowskiUrbanAchievers--width100pct</code>
      answer-toggle(correct="false") <code>.Btn-------bigger</code>
      answer-toggle(correct="false") <code>.DialogBox-iconTopLeft</code>
      answer-toggle(correct="false") <code>.SmallText--mini-evenSmaller</code>
      answer-toggle(correct="true") <code>.DialogBox--funAndColorful</code>

  question
    h5 Which are valid usages of Modifier classes?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          <button class="Btn Btn--big Btn--colorfulAndSquiggily">
            Click Me
            <span class="Btn-iconImage Btn-iconImage--bigger"></span>
          </button>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn">
            Click Me
            <span class="Btn-iconImage--bigger"></span>
          </button>
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          <div class="SearchBox">
            <b class="SearchBox-title
                      SearchBox-title--bigger"></b>
          </div>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn">
            Click Me
            <span class="Btn-iconImage
                         Btn-icon--bigger"></span>
          </button>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn--bigger">
            Click Me
            <span class="Btn-iconImage"></span>
          </button>
          ```
section
  :markdown
    # Programmatically toggling styles with JavaScript

    Our favorite way to effect styling with JavaScript is to add and remove
    classes. It is a simple, yet extremely powerful way of dynamically changing
    styles and/or triggering animation in response to user interaction.

    The FSG lets us toggle classes in two ways:

    1. By toggling Modifier classes
    2. By toggling State (`.is`) classes

    # State Classes (**`.is`**)

    State class names are camelCased class names that begin with `.is`.
    These classes are special because:

    - State classes are the only type of class that
      we can use in a Module file which are *not* namespaced by the Module name.
    - State classes may not have styles on their own.

    > **Note** that a state class may **not** be the final descendent/child in a
    selector (for example: `.Btn-iconImage .isActive { ... }`)
    because we consider this to be giving the State class a style
    of it's own.


    # Toggling styles with JavaScript: done 2 ways

    There is no simple answer regarding which type of class (Modifier or Sate) should be used to
    toggle styling. Instead, we should consider both options for each particular use-case
    and choose the one that seems the most intuitive.

    Consider, for example, that our design calls for several widgets that are styled one way
    for users whom aren't logged in, and styled another way for users whom are logged in.
    What follows are the two different approaches to accomplish this objective,
    implemented in AngularJS.

    ## Approach #1: Toggling Modifier classes

    ``` html
    <body>
      <div class="Header" ng-class={'Header--loggedIn':userIsLoggedIn}">...</div>
      <div class="Hero" ng-class={'Hero--loggedIn':userIsLoggedIn}">...</div>
      <div class="FeatureGrid" ng-class={'FeatureGrid--loggedIn':userIsLoggedIn}">...</div>
    </body>
    ```

    ``` css
    /* modules/_Header.scss */
    .Header {
      ...
    }
    .Header--loggedIn {
      ...
    }

    /* modules/_Hero.scss */
    .Hero {
      ...
    }
    .Hero--loggedIn {
      ...
    }

    /* modules/_FeatureGrid.scss */
    .FeatureGrid {
      ...
    }
    .FeatureGrid--loggedIn {
      ...
    }
    ```

    > **Note** that in this first approach we are exclusively using Module Modifiers,
    however it is possible to use Element Modifiers instead or as well.

    ## Approach #2: Toggling State (`.is`) classes

    ``` html
    <body ng-class="{isLoggedIn:userIsLoggedIn}">
      <div class="Header">...</div>
      <div class="Hero">...</div>
      <div class="FeatureGrid">...</div>
    </body>
    ```

    ``` css
    /* modules/_Header.scss */
    .Header {
      ...
    }
    .isLoggedIn.Header {
      ...
    }

    /* modules/_Hero.scss */
    .Hero {
      ...
    }
    .isLoggedIn.Hero {
      ...
    }

    /* modules/_FeatureGrid.scss */
    .FeatureGrid {
      ...
    }
    .isLoggedIn.FeatureGrid {
      ...
    }
    ```


questions.Questions--2
  question
    h5 Which selectors are allowed?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          .isLoggedIn.Btn-imageIcon {
            background: red;
          }
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          Btn-imageIcon > .isLoggedIn {
            background: red;
          }
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          .SearchForm.isSuperUser {
            font-size:10px;
            color: blue
          }
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .SearchForm .isSuperUser.Btn {
            font-size:10px;
            color: blue
          }
          ```
  question
    h5 Valid State class name?
    answer-toggle-group
      answer-toggle(correct="true") <code>.isUserLoggedIn</code>
      answer-toggle(correct="false") <code>.isUser-loggedIn</code>
      answer-toggle(correct="false") <code>.userIsLoggedIn</code>
      answer-toggle(correct="true") <code>.isOK</code>
      answer-toggle(correct="false") <code>.IsFormValid</code>

section
  :markdown
    # Nesting Modules inside of Modules

    So far, we have mostly focused on understanding the building blocks
    that are made available to us by the FSG. Module Elements
    are the primary building blocks of Modules. Modules are how
    we encapsulate reusable parcels of styling. Modifiers are what we
    use to create variations of existing styles. State classes
    are like global variables that we can use with JavaScript to trigger
    interactive style changes.

    The way these building blocks fit together logically in our markup is primarily
    via the creation of a nested tree of Modules. **To facilitate *maximum* code modularity
    and maintainability, our Module nesting structure should adhere to
    the following 2 guidelines**:

    1. **The top-level `.Module` and `.Module--modifier` classes should not have values set for
      the `width`, `top`, `bottom`, `left`, `right`, `margin`, and `float` properties**.
      (The CSS default value is `0` for `margin`, `none` for `float`, and `auto` for the rest.)
      If we feel that we must break this rule, then we should do so with Modifiers
      named in such a way that makes such exceptions easy to identifity from within the markup,
      for example:

      ``` html
      <div class="SearchBar SearchBar--w180px">...</div>
      ```

      ``` css
      .SearchBar--w180px {
          width: 180px;
      }
      ```

    2. A DOM element should never contain classes from different Modules. In other words,
      **Modules should not share boundaries.** For example:

      ``` html
      <div class="Hero">
          <div class="Hero-searchBar">
              <div class="SearchBar">...</div>
          </div>
      </div>
      ```

      is preferred over:

      ``` html
      <div class="Hero">
          <div class="Hero-searchBar SearchBar">...</div>
      </div>
      ```

      > **Note** that the preferred (first) approach is also necessary to fascilitate
      loading multiple CSS files asynchronously

    ## The Big Picture

    Let's take a step back and look at what the nesting structure should look like
    in a complete web page:

    ``` html
    <body>
      <div class="App">

        <header class="Header">...</header>

        <div class="Hero">
          <div class="Hero-centerRight">
            <div class="SearchBar">...</div>
          </div>
        </div>

        <section class="ArticleList">
          <div class="ArticleList-article">
            <article class="Article">...</article>
          </div>
        </section>

        <footer class="Footer">...</footer>

      </div>
    </body>
    ```

    Because we are following the FSG, we can determine some information
    about the structural styling in this webpage just by looking at the markup:

    - `.Header`, `.Hero`, `.ArticleList`, and `.Footer` are probably block-level
      elements that take up the full width of the page (because a block-level element
      will by default fill its parent container).

    - The `.Hero-centerRight` element is used to size and/or position the nested `.SearchBar`
      Module.

    - The `.ArticleList-article` Element is used to size and/or position the nested `.Article`
      Module.

    One of the most important take-aways from the example above is that **a parent
    Module is responsible for positioning and sizing it's nested children**.
    Conversely, a Module should *not* position and size *itself*.

questions.Questions--2
  question
    h5 What are preferred ways to set width of <code>.SearchWidget</code>?
    answer-toggle-group
      answer-toggle(correct="false")
        :markdown
          ```
          <div class="SideBar">
            <div class="SearchWidget SearchWidget--250px">...</div>
          </div>
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          <div class="SideBar">
            <div class="SideBar-searchWidget">
              <div class="SearchWidget">...</div>
            </div>
          </div>
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          <div class="SideBar">
            <div class="SideBar-halfWidth">
              <div class="SearchWidget">...</div>
            </div>
          </div>
          ```
  question
    h5 Which are preferred <em>or</em> acceptable ways to set width of <code>.SearchWidget</code>?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          .SearchWidget--250px {
            width: 250px;
          }

          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .SearchWidget {
            width: 250px;
          }

          ```
      answer-toggle(correct="true")
        :markdown
          ```
          .SideBar-searchWidget {
            width: 250px;
          }
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .SideBar .SearchWidget {
            width: 250px;
          }
          ```