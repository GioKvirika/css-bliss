section
  :markdown

    # FSG Walkthrough

    Welcome! Throughout this walkthrough the [futuristic-sass-guide](https://github.com/gilbox/futuristic-sass-guide)
    is referred to as the **FSG**.
    The purpose of this walkthrough is to present the FSG in a more natural way. If the FSG is
    the technical manual, then this is the study guide.

section
  :markdown

    # Subclassing

    The term **subclassing** is used several times throughout the FSG. This is a very
    important concept because subclassing is often better than using `@extend` or `@mixin`.
    When `.A` and `.B` are applied to the same element `<div class="A B">`,
    we say that `.B` **subclasses** `.A` **if `.B` appears after `.A` in the stylesheet**
    (and thus will override or augment rules in `.A`)

questions.Questions--3
  question
    :markdown
      ``` css
        .A {
         color: red;
         border: 1px solid green;
        }

        .B {
         color: blue;
        }
      ```

      ``` html
        <h2 class="A B">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="true") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") Both <code>A</code> subclasses <code>B</code>, and <code>B</code> subclasses <code>A</code>

  question
    :markdown
      ``` css
        .B {
         font-size: 20px;
        }
        .A {
         color: orange;
        }
      ```
      ``` html
        <h2 class="A B">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="true") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="false") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") Both <code>A</code> subclasses <code>B</code>, and <code>B</code> subclasses <code>A</code>

  question
    :markdown
      ``` css
        .A { ... }
        .B { ... }
        .C { ... }
      ```
      ``` html
        <h2 class="C B A">
          Hello World
        </h2>
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>A</code> subclasses <code>B</code>
      answer-toggle(correct="true") <code>B</code> subclasses <code>A</code>
      answer-toggle(correct="false") <code>B</code> subclasses <code>C</code>
      answer-toggle(correct="true") <code>C</code> subclasses <code>A</code>
      answer-toggle(correct="true") <code>C</code> subclasses both <code>B</code> <strong>and</strong> <code>A</code>

section
  :markdown

    # Creating a new Module

    Whenever we need to add new styles to a page, our first instinct should be to
    create a new **Module** or to augment an existing Module.

    Module class names are **.TitleCase** and should reside inside of a SASS partial
    named after the Module. Module files (partials) live inside the `modules/` folder.
    For example, a `.DialogBox` Module should be defined inside of `modules/_DialogBox.scss`.

    All classes names inside of a Module file must be namespaced by
    the Module name. A class is namespaced with the module name followed by dash (ie `.DialogBox-`).
    The only exception to this are state classes, which are classes which are never
    namespaced and begin with `.is`

questions.Questions--3
  question
    :markdown
      ``` css
        .FunBox {
          width:100%;
        }

        .FunBox-btn {
          border: 5px solid green;
          white-space: nowrap;
        }

        .isActive.FunBox-btn {
          color: red;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="true") Is this a valid Module File?

  question
    :markdown
      ``` css
        .SearchBox {
          border: 1px solid black;
        }

        .SearchBox-closeBtn {
          background: black;
          color:white;
        }

        .SearchButton {
          text-decoration: none;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") Is this a valid Module File?

  question
    h5 Which of the following are valid Module Names?
    answer-toggle-group
      answer-toggle(correct="true") Btn
      answer-toggle(correct="false") SearchBox-closeBtn
      answer-toggle(correct="false") jokeBox
      answer-toggle(correct="true") DialogBoxBtn
      answer-toggle(correct="false") HeaderWidget-Lower
      answer-toggle(correct="false") Promo_Banner

section
  :markdown

    # Adding Rules to Modules

    Any time we need to add a style rule to a Module, our first instinct
    should be to add a **Module Element** class to the module. For example,
    if we have a Module `.Btn` and need to style an image icon within the button
    then we create the class `.Btn-imageIcon`. Note how `imageIcon` is camelCase and is namespaced by
    the Module, `.Btn-`.

    Here's what our button looks like in code:

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }
    ```

    ``` html
    <button class="Btn">
      Click Me <span class="Btn-imageIcon"></span>
    </button>
    ```

questions.Questions--2
  question
    h5 Which are valid Module Element classes?
    answer-toggle-group
      answer-toggle(correct="false") .Btn-vector-icon
      answer-toggle(correct="false") .Btn-Middle
      answer-toggle(correct="true") .Btn-iconTopLeft
      answer-toggle(correct="false") .Btn-icon--small
      answer-toggle(correct="false") .btnIcon
      answer-toggle(correct="true") .Btn-littleLebowskiUrbanAchievers

  question
    :markdown
      ``` css
        .SearchBox {
          border: 1px solid black;
        }
        .SearchBox-closeBtn {
          background: black;
          color:white;
        }
        .SearchBox-expandBtn {
          background: blue;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>.SearchBox</code> is a Module Element
      answer-toggle(correct="true") <code>.SearchBox-closeBtn</code> is a Module Element
      answer-toggle(correct="true") <code>.SearchBox-expandBtn</code> is a Module Element

section
  :markdown
    # Modifying Module Elements

    Now, consider that our designer comes along and hands us a new requirement
    for a new button. This new button is very similar to our existing button
    with it's icon, except that this new button has a *bigger* icon. One way to
    create this new style is with a **Module Element Modifier**.

    ``` html
    <button class="Btn">
      Click Me <span class="Btn-imageIcon Btn-imageIcon--bigger"></span>
    </button>
    ```

    In the markup above, `.Btn-imageIcon--bigger` is our new **Module Element Modifier**.
    Note that this new Modifier **subclasses** our original **Module Element**
    `Btn-imageIcon`. Here's what the updated stylesheet looks like:

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }

    .Btn-imageIcon--bigger {
      height: 30px;
    }
    ```

    Modifiers **always** follow these two rules:

    1. Modifiers always subclass another class
    2. Modifiers are always named after the class which they subclass with the addition
       of 2 dashes, followed by a camelCased name

    Modifiers are also unique because **we may apply multiple Modifiers to one DOM element**.
    In contrast, we are **not** allowed to apply multiple Module or Module Element classes
    to the same DOM element.

    # Modifying Modules

    As an alternative to using **Element Modifiers**, we can create variations of existing styles
    using **Module Modifiers**. Consider again the same scenario presented above where
    a design change calls for a new button. Here's what the new markup will look like
    if we use a Module Modifier instead of an Element Modifier:

    ``` html
    <button class="Btn Btn--bigger">
      Click Me <span class="Btn-imageIcon"></span>
    </button>
    ```

    To create a syling rule for our Module Modifier, this is one of the few times when
    the FSG recommends using a
    [**descendant selector**](http://www.w3.org/TR/CSS21/selector.html#descendant-selectors):

    ``` css
    .Btn {
      border: 2px solid grey;
      background: red;
    }

    .Btn-imageIcon {
      position:inline-block:
      height: 15px;
    }

    .Btn--bigger .Btn-imageIcon { /* this is a descendant selector */
      height: 30px;
    }
    ```

questions.Questions--3
  question
    :markdown
      ``` css
        .DialogBox {
          border: 1px solid black;
        }

        .DialogBox-closeBtn--bigger {
          height: 30px;
        }

        .DialogBox-closeBtn {
          background: black;
          color:white;
          height: 30px;
        }

        .DialogBox-expandBtn {
          background: blue;
        }

        .DialogBox-expandBtn--bigger {
          background: blue;
        }
      ```
    answer-toggle-group
      answer-toggle(correct="false") <code>.DialogBox-closeBtn--bigger</code> is ordered correctly in the CSS file
      answer-toggle(correct="true") <code>.DialogBox-expandBtn--bigger</code> is ordered correctly in the CSS file

  question
    h5 Which are valid <em>Element</em> Modifier classes?
    answer-toggle-group
      answer-toggle(correct="false") .Btn--smaller
      answer-toggle(correct="true") .Btn-iconTop--smaller
      answer-toggle(correct="false") .DialogBox--fun-pullRight
      answer-toggle(correct="true") .DialogBox-iconTopLeft--pushLeft
      answer-toggle(correct="false") .SmallText-mini-evenSmaller
      answer-toggle(correct="true") .Btn-littleLebowskiUrbanAchievers--width100pct

    h5 Which are valid <em>Module</em> Modifier classes?
    answer-toggle-group
      answer-toggle(correct="true") .Btn--smaller
      answer-toggle(correct="false") .Btn-littleLebowskiUrbanAchievers--width100pct
      answer-toggle(correct="false") .Btn-------bigger
      answer-toggle(correct="false") .DialogBox-iconTopLeft
      answer-toggle(correct="false") .SmallText--mini-evenSmaller
      answer-toggle(correct="true") .DialogBox--funAndColorful

  question
    h5 Which are valid usages of Modifier classes?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          <button class="Btn Btn--big Btn--colorfulAndSquiggily">
            Click Me
            <span class="Btn-iconImage Btn-iconImage--bigger"></span>
          </button>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn">
            Click Me
            <span class="Btn-iconImage--bigger"></span>
          </button>
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          <div class="SearchBox">
            <b class="SearchBox-title
                      SearchBox-title--bigger"></b>
          </div>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn">
            Click Me
            <span class="Btn-iconImage
                         Btn-icon--bigger"></span>
          </button>
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          <button class="Btn--bigger">
            Click Me
            <span class="Btn-iconImage"></span>
          </button>
          ```
section
  :markdown
    # Programmatically toggling styles with JavaScript

    Our favorite way to effect styling with JavaScript is to add and remove
    classes. It is a simple, yet extremely powerful way of dynamically changing
    styles and/or triggering animation in response to user interaction.

    The FSG lets us toggle classes in two ways:

    1. By toggling Modifier classes
    2. By toggling State (`.is`) classes

    # State Classes (**`.is`**)

    State class names are camelCased class names that begin with `.is`.
    These classes are special because:

    - State classes are the only type of class that
      we can use in a Module file which are *not* namespaced by the Module name.
    - State classes may not have styles on their own.

    > **Note** that a state class may **not** be the final descendent/child in a
    selector (for example: `.Btn-iconImage .isActive { ... }`)
    because we consider this to be giving the State class a style
    of it's own.


    # Toggling styles with JavaScript: done 2 ways

    There is no simple answer regarding which type of class should be used to
    toggle styling. The best we can do is to consider two ways to accomplish
    the same goal.

    Imagine that our webpage has several widgets that are styled one way
    for users whom aren't logged in, and another way for users whom are.
    What follows are two different approaches to accomplish our goal,
    implemented in AngularJS.

    ## Approach #1: Toggling Modifier classes

    ``` html
    <body>
      <div class="Header" ng-class={'Header--loggedIn':userIsLoggedIn}">...</div>
      <div class="Hero" ng-class={'Hero--loggedIn':userIsLoggedIn}">...</div>
      <div class="FeatureGrid" ng-class={'FeatureGrid--loggedIn':userIsLoggedIn}">...</div>
    </body>
    ```

    ``` css
    /* modules/_Header.scss */
    .Header {
      ...
    }
    .Header--loggedIn {
      ...
    }

    /* modules/_Hero.scss */
    .Hero {
      ...
    }
    .Hero--loggedIn {
      ...
    }

    /* modules/_FeatureGrid.scss */
    .FeatureGrid {
      ...
    }
    .FeatureGrid--loggedIn {
      ...
    }
    ```

    ## Approach #2: Toggling State (`.is`) classes

    ``` html
    <body ng-class="{isLoggedIn:userIsLoggedIn}">
      <div class="Header">...</div>
      <div class="Hero">...</div>
      <div class="FeatureGrid">...</div>
    </body>
    ```

    ``` css
    /* modules/_Header.scss */
    .Header {
      ...
    }
    .isLoggedIn.Header {
      ...
    }

    /* modules/_Hero.scss */
    .Hero {
      ...
    }
    .isLoggedIn.Hero {
      ...
    }

    /* modules/_FeatureGrid.scss */
    .FeatureGrid {
      ...
    }
    .isLoggedIn.FeatureGrid {
      ...
    }
    ```

    > **Note** that in this second approach we are exclusively using Module Modifiers,
    however it is possible to use Element Modifiers instead/also.

questions.Questions--2
  question
    h5 Which selectors are allowed?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          .isLoggedIn.Btn-imageIcon {
            background: red;
          }
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          Btn-imageIcon > .isLoggedIn {
            background: red;
          }
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          .SearchForm.isSuperUser {
            font-size:10px;
            color: blue
          }
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .SearchForm .isSuperUser.Btn {
            font-size:10px;
            color: blue
          }
          ```
  question
    h5 Valid State class name?
    answer-toggle-group
      answer-toggle(correct="true")
        :markdown
          ```
          .isUserLoggedIn
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .isUser-loggedIn
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .userIsLoggedIn
          ```
      answer-toggle(correct="true")
        :markdown
          ```
          .isOK
          ```
      answer-toggle(correct="false")
        :markdown
          ```
          .IsFormValid
          ```